*klen_lib.txt*	For Vim version 8.2	Last change: 2021 Nov 23

			  Library of custom functions

This file documents the functions defined in the files under
~/.vim/autoload/klen/. They can be used like normal functions: call them by
exactly as they appear below.

1.  Function list		    |klen-function-list|
2.  Function documentation	    |klen-functions|

==============================================================================
1.	Function list				*klen-function-list*

Functions are grouped by the file in which they are defined. Enter CTRL-] with
the cursor over a function name to view it in more detail.

genlib.vim ~
						*klen-genlib-functions*
List manipulation:
	klen#genlib#peek()		gets the last item of a List
	klen#genlib#pop()		removes the last item of a List
	klen#genlib#push()		adds an item to the end of a List

Cursor:
	klen#genlib#cursor_char()	gets the character at the cursor
	klen#genlib#cursor_char_byte()	gets the byte index of the character
					at the cursor

str.vim ~
						*klen-string-functions*
String manipulation:
	klen#str#byteidx_quote_positions()
					returns the byte indices of the
					matching quotes surrounding the given
					byte index in a string
	klen#str#char_escaped()		checks if the character at the given
					byte index is escaped
	klen#str#get_delimiters()	gets the byte indices of the specified
					delimiters in a string
	klen#str#get_same_delimiters()	gets the byte index of the specified
					delimiter in a string whose opening
					and closing notations are the same
	klen#str#match_chars()		checks whether all characters between
					two byte indices match the given
					pattern

==============================================================================
2.	Function documentation				*klen-functions*

See |klen-function-list| for a list of functions grouped by file name and
then by category, each of which is sorted alphabetically.

klen#genlib#peek({stack})				*klen#genlib#peek()*
	Expects: type({stack}) == v:t_list && !empty({stack})
	Ensures: returns the last item of {stack}.

klen#genlib#pop({stack})				*klen#genlib#pop()*
	Expects: type({stack}) == v:t_list && !empty({stack})
	Ensures: removes the last item of {stack}.

klen#genlib#push({stack}, {item})			*klen#genlib#push()*
	Expects: type({stack}) == v:t_list
	Ensures: adds {item} to the end of {stack}.

klen#genlib#cursor_char([{prev} [, {pat}]])	*klen#genlib#cursor_char()*
	Expects: Optional parameters:
		 type({prev}) == v:t_bool
		 type({pat}) == v:t_string
	Ensures: returns the character at the cursor. If such a character does
		 not exist, returns an empty string. If {prev} is true,
		 returns the character before the cursor instead. If {pat} is
		 specified, returns the first character that matches {pat}
		 after the cursor--before if {prev} is true. Composing
		 characters are ignored.

					*klen#genlib#cursor_char_byte()*
klen#genlib#cursor_char_byte([{prev} [, {pat}]])
	Expects: Optional parameters:
		 type({prev}) == v:t_bool
		 type({pat}) == v:t_string
	Ensures: Like |klen#genlib#cursor_char()|, but returns the byte index
		 of the character at the cursor. If such a character does not
		 exist, returns -1. The optional parameters {start} and {pat}
		 have the same meaning as |klen#genlib#cursor_char()|.
		 Composing characters are not counted separately.

					*klen#str#byteidx_quote_positions()*
klen#str#byteidx_quote_positions({string}, {index})
	Expects: type({string}) == v:t_string && type{{index}) == v:t_number
	Ensures: returns a List indicating the byte indices of the quotation
		 marks of the string containing the byte index {index} in
		 {string}. If an unmatched quote precedes {index}, returns a
		 List containing that quote's byte index and a -1. This
		 function can be used to check if {index} is within a string,
		 which may be delimited with single or double quotes
		 |klen#str#get_same_delimiters()|. If {index} is not in a
		 string or is out of range ({index} < 0 or
		 {index} >= strlen({string})), returns [-1, -1].
			Index	Quote
			0	opening
			1	closing

		 This function has one unique case: if {index} corresponds to
		 the quote of a string, a List with the quote's and its
		 matching quote's byte indices is returned; alternatively, a
		 List with the quote's byte index and a -1 is returned if the
		 quote is unmatched.

						*klen#str#char_escaped()*
klen#str#char_escaped({string}, {index} [, {char}])
	Expects: type({string}) == v:t_string && type({index}) == v:t_number
		 Optional parameters:
		 type({char}) == v:t_string
	Ensures: returns true if the character at {index} in {string} is
		 escaped with a {char}, i.e., an odd number of {char}s
		 precedes the character. By default, {char} is a backslash;
		 {char} may be more than one character.

						*klen#str#get_delimiters()*
klen#str#get_delimiters({string}, {delims} [, {unmatched}])
	Expects: type({string}) == v:t_string && type({delims}) == v:t_list
		 && len({delims}) == 2
		 && for item in {delims}, type(item) == v:t_string
		 Optional parameters:
		 type({unmatched}) == v:t_bool
	Ensures: returns a List of two Lists indicating the starting byte
		 indices of the matched delimiters given by {delims} in
		 {string}. NOTE: If the opening and closing delimiters are the
		 same, use |klen#str#get_same_delimiters()|. The first List
		 contains the indices of matched opening delimiters, while the
		 second List contains the indices of matched closing
		 delimiters. Either List may be empty, and the Lists are
		 associative. Nested delimiters are ordered from the innermost
		 to the outermost pair. If {unmatched} is true, returns a List
		 of four Lists: the first two Lists contain the byte indices
		 of the matched delimiters, while the last two Lists contain
		 the byte indices of the unmatched delimiters.
			Index	Delimiter
			0	opening
			1	closing
		 If {unmatched} is true,
			2	unmatched opening
			3	unmatched closing

		 {delims} must contain two Strings: the first String is the
		 opening delimiter, and the second String is the closing
		 delimiter.

					*klen#str#get_same_delimiters()*
klen#str#get_same_delimiters({string}, {delim} [, {unmatched}])
	Expects: type({string}) == v:t_string && type({delim}) == v:t_string
		 Optional parameters:
		 type({unmatched}) == v:t_bool
	Ensures: returns a List containing the starting byte indices of the
		 matched delimiters specified by {delim} in {string}.
		 Naturally, this List is ordered. If no such delimiters exist,
		 returns an empty List. If {unmatched} is true, returns a List
		 of two Lists: the first contains the matched delimiters, and
		 the second has at most one element, which is the starting
		 byte index of the unmatched {delim}. If {delim} is a quote (a
		 ' or "), ignores escaped instances of {delim} in a string;
		 instances of {delim} in a string delimited by the alternative
		 quotes, i.e., single quotes between double quotes; and
		 instances of {delim} immediately after a word character
		 outside a string. A string can be delimited by single or
		 double quotes.
		 If {unmatched} is true,
			Index	Delimiter type
			0	Matched
			1	Unmatched

		 Examples:
			:echo klen#str#get_same_delimiters("\"'Twas\"", "'",
						\ v:true)
		 returns [[], []];
			:echo klen#str#get_same_delimiters("'\\''", "'",
						\ v:true)
		 returns [[0, 3], []]; and
			:echo klen#str#get_same_delimiters("'\"', \"start",
						\ "\"", v:true)
		 returns [[], [5]].

						*klen#str#match_chars()*
klen#str#match_chars({expr}, {pat}, {start}, {end})
	Expects: (type({expr}) == v:t_string || type({expr}) == v:t_list
		  && for {str} in {expr}, type({str}) == v:t_string)
		 && type({pat}) == v:t_string
		 && (type({start}) == v:t_number
		     || type({start}) == v:t_list && type({expr}) == v:t_list
		     && len({start}) == 2
		     && for {n} in {start}, type({n}) == v:t_number
		     && 0 <= {start}[0] < len({expr}))
		 && (type({end}) == v:t_number
		     || type({end}) == v:t_list && type({expr}) == v:t_list
		     && len({end}) == 2
		     && for {n} in {end}, type({n}) == v:t_number
		     && 0 <= {end}[0] < len({expr}))
	Ensures: returns the number of characters, including new lines,
		 between the byte indices {start} and {end} in the string
		 {expr} if all characters match {pat}. If {expr} is a List,
		 {start} and {end} may also appear as Lists of the form
			[{lidx}, {byteidx}]
		 In this case, the characters after {start}, before {end}, and
		 between the line indices of {start} and {end} in {expr} are
		 matched with {pat}. Keeping {start} as a number will
		 implicitly set {lidx} to zero, i.e., the index of the first
		 string in {expr}. Likewise, if {end} is a number, its {lidx}
		 is set to the length of {expr} minus one: the last string in
		 {expr}.

		 If 'delcombine' is set, composing characters are counted
		 separately. Otherwise, they are ignored.

		 If {expr} is a string and {start} < 0 or
		 {end} > strlen({expr}), the start or end of {expr} will be
		 used instead for the offending argument. If {expr} is a List
		 and the {byteidx} of {start} or {end} exceeds the bounds of
		 its corresponding string in {expr}, the start or end of that
		 string will be used instead. If {end} appears before {start}
		 or a character does not match {pat}, returns -1. This
		 function can be used to check whether certain characters lie
		 between {start} and {end}.

 vim:tw=78:isk=!-~,^*,^\|,^\":ts=8:noet:ft=help:norl:
